#!/usr/bin/python -uO

import sys
import os
import time
import tty
import termios
import argparse
import select
import curses
import serial
import struct
import re
import locale
import math
import fcntl
import signal
import traceback
from threading import Thread
from collections import defaultdict

SECONDS_PER_HOUR = 3600
GPS_OFFSET_SECONDS = 315964786
SECONDS_PER_WEEK = 604800
HOURS_PER_WEEK = 168

locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()
degree = unichr(0xb0).encode(code)

ex_string = None
width = 80
gps_device = None
hasfix = False
lostfix = time.time()
gotfix = time.time()
paused = False
nmea_paused = False
stdscr = None
ll = re.compile(r"(\d?\d\d)(\d\d)(\.\d\d\d\d)")
fix = defaultdict(lambda: "None", {"0": "None", "1": "GPS", "2": "DGPS", "6":"DRM"})
speed_units = defaultdict(lambda: "??",{"N": "Kn", "K": "KPH"})
modes_t = defaultdict(lambda: "NA", {"1": "NA", "2": "2D", "3": "3D"})
draws = {}
clears = {}
w = {}
s = {}
f = {}

baudrate = {
    termios.B4800: 4800,
    termios.B9600: 9600,
    termios.B19200: 19200,
    termios.B38400: 38400,
    termios.B57600: 57600,
    termios.B115200: 115200,
}

def Convert2UTC(GPSHour):
    GPSHour *= SECONDS_PER_HOUR
    GPSHour += GPS_OFFSET_SECONDS
    return time.strftime("%Y-%m-%d %H:%M:%SZ", time.gmtime(GPSHour))

def Convert2Local(GPSHour):
    GPSHour *= SECONDS_PER_HOUR
    GPSHour += GPS_OFFSET_SECONDS
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(GPSHour))

def crc8(d):
    crc = 0
    for b in bytearray(d):
        crc ^= (b & 0xff)
    return crc

def convert_arg_line_to_args(arg_line):
    for arg in arg_line.split():
        if not arg.strip():
            continue
        yield arg

def send_string(fg, string):
    fg.flushInput()
    fg.write("$%s*%02x\r\n" % (string, crc8(string)))
    fg.flushInput()
    fg.flushOutput()

def format_dms(dddmm, direction):
    s = ll.split(dddmm)
    if len(s) < 3:
        return " " * 17
    return "%3s%s %2s' %05.2f\" %s" % \
        (s[1], unichr(0xb0).encode(code), s[2], float(s[3]) * 60.0, direction)

def format_heading(heading, ref):
    try:
        return "%3d%s%s" % (math.floor(float(heading)), unichr(0xb0).encode(code), ref)
    except:
        return "     "
    
def draw_string(win, row, col, st, erase=-1):
    if erase < 0: erase = len(st)
    dw = win.derwin(1, erase, row, col)
    t1 = dw.instr(row, col, erase)
    if (st == t1): return False
    dw.erase()
    try:
        dw.addstr(0, 0, st)
    except:
        pass
#    print >>sys.stderr, time.time(), "'%s'" % t1, "'%s'" % st
    dw.refresh()
    del dw
    return True

def draw_win(wid, name, rows, cols, row, col):
    if wid in w: del w[wid]
    if wid in s: del s[wid]
    w[wid] = curses.newwin(rows, cols, row, col)
    w[wid].border()
    w[wid].addstr(0, 2, name)
    w[wid].refresh()
    y, x = w[wid].getmaxyx()
    s[wid] = w[wid].derwin(y-2, x-2, 1, 1)
    if wid in draws: draws[wid]()
    
def draw_nav():
    win = s['NAV']
    draw_string(win, 0, 0, " Latitude: ")
    draw_string(win, 1, 0, "Longitude: ")
    draw_string(win, 0, 30, " Alt (M): ")
    draw_string(win, 1, 30, "Alt (Ft): ")

    draw_string(win, 0, 52, "Track: ")
    draw_string(win, 1, 52, "Speed: ")
draws['NAV'] = draw_nav    

def draw_time():
    win = s['TIME']
    draw_string(win, 0, 0, "Date: ")
    draw_string(win, 0, 18, "Time: ")
    draw_string(win, 0, 33, "UTC")
draws['TIME'] = draw_time    

def draw_sat():
    win = s['SAT']
    draw_string(win, 0, 0, "  Sat: ")
    draw_string(win, 1, 0, "Elev%s: " % degree)
    draw_string(win, 2, 0, "  Az%s: " % degree)
    draw_string(win, 3, 0, "  SNR: ")
    
    draw_string(win, 0, 58, "Fix Type: ")
    draw_string(win, 1, 58, "    Sats: ")
    draw_string(win, 2, 58, "    TTFF: ")
    draw_string(win, 3, 58, "  Err(M): ")
    
    y, x = win.getmaxyx()
    win.hline(4, 0, curses.ACS_HLINE, x)
    win.refresh()
    draw_string(win, 5, 0, "  EPO: ")
draws['SAT'] = draw_sat

def clear_nav():
    win = s['NAV']
    draw_string(win, 0, 11, "", 18)
    draw_string(win, 1, 11, "", 18)
    draw_string(win, 0, 40, "", 8)
    draw_string(win, 1, 40, "", 8)
    draw_string(win, 0, 60, "", 16)
    draw_string(win, 1, 60, "", 16)
clears['NAV'] = clear_nav

def clear_time():
    win = s['TIME']
    draw_string(win, 0, 6, "", 10)
    draw_string(win, 0, 24, "", 8)
clears['TIME'] = clear_time

def clear_status():
    draw_string(s['STATUS'], 0, 0, paused and "Paused" or "Running", 15) 
clears['STATUS'] = clear_status

def clear_sat():
    win = s['SAT']
    draw_string(win, 0, 7, " ", 16 * 4)
    draw_string(win, 1, 7, " ", 16 * 4)
    draw_string(win, 2, 7, " ", 16 * 4)
    draw_string(win, 3, 7, " ", 16 * 4)
    draw_string(win, 5, 7, " ", 70)
    draw_string(win, 0, 67, " ", 11)  
    draw_string(win, 1, 67, " ", 11)
    draw_string(win, 2, 67, " ", 11)
    draw_string(win, 3, 67, " ", 11)
clears['SAT'] = clear_sat

def clear_nmea():
    win = s['NMEA']
    win.erase()
    win.refresh()
clears['NMEA'] = clear_nmea

def update_loc(lat, latdir, lon, londir):
    win = s['NAV']
    refresh = draw_string(win, 0, 11, format_dms(lat, latdir))
    refresh |= draw_string(win, 1, 11, format_dms(lon, londir))
    return refresh
 
def update_alt(alt):
    win = s['NAV']
    try:
        altM = float(alt)
        altF =  altM * 3.28084
        refresh = draw_string(win, 0, 40, "%7.1f" % altM)
        refresh |= draw_string(win, 1, 40, "%7.1f" % altF)
    except:
        refresh = draw_string(win, 0, 40, " " * 7)
        refresh |= draw_string(win, 1, 40, " " * 7)
        
    return refresh
            
def update_time(date, tm):
    win = s['TIME']
    refresh = False
    refresh |= draw_string(win, 0, 6, date)
    refresh |= draw_string(win, 0, 24, tm)
    return refresh
    
def GPGGA(a):
    global lostfix, hasfix, gotfix
    if len(a) < 11:
        return
    refresh = False
    
    refresh |= update_loc(a[2], a[3], a[4], a[5])
    refresh |= update_alt(a[9])

    newhasfix = (fix[a[6]] != "None")

    if hasfix and not newhasfix:
        lostfix = time.time()
        
    if not hasfix and newhasfix:
        gotfix = time.time()
        
    hasfix = newhasfix
    
    if hasfix:
        ttff = gotfix - lostfix
    else:
        ttff = time.time() - lostfix

    win = s['SAT']    
    refresh |= draw_string(win, 0, 67, "%7.7s" % fix[a[6]])  
    refresh |= draw_string(win, 1, 67, "%7.7s" % a[7])
    refresh |= draw_string(win, 2, 67, "%7d" % ttff)

    corr = 1.5 if fix[a[6]] == "DGPS" else 5.1
    try:
        error = float(a[8]) * corr
    except:
        error = -0.0
    refresh |= draw_string(win, 3, 67, "%7.1f" % error)
f['GPGGA'] = GPGGA

def GPGLL(a):
    if len(a) < 5:
        return
    update_loc(a[1], a[2], a[3], a[4])
f['GPGLL'] = GPGLL

def GPRMC(a):
    if len(a) < 10:
        return
    if len(a[9]):
        update_time("20%2s-%2s-%2s" % (a[9][4:6], a[9][2:4], a[9][0:2]),
            "%2s:%2s:%2s" % (a[1][0:2], a[1][2:4],a[1][4:6]))
    update_loc(a[3], a[4], a[5], a[6])
    
    try:
        GPVTG(["", a[8], "T", "", "", a[7], "", float(a[7]) * 1.852, a[8]])
    except:
        pass
    
    
    
f['GPRMC'] = GPRMC

def GPGSA(a):
    if len(a) < 3:
        return
    draw_string(s['SAT'], 0, 75, "%3.3s" % modes_t[a[2]])
f['GPGSA'] = GPGSA

def GPGSV(a):
    refresh = False
    w = s['SAT']
        
#    messages = a[1].isdigit() and int(a[1]) or 0
    message = a[2].isdigit() and int(a[2]) or 0
#    siv = a[3].isdigit() and int(a[3]) or 0

    if len(a) >= 8:
        s1 = a[4:8]
    else:
        s1 = [" "," "," "," "]
        
    if len(a) >= 12:
        s2 = a[8:12]
    else:
        s2 = [" "," "," "," "]
        
    if len(a) >= 16:
        s3 = a[12:16]
    else:
        s3 = [" "," "," "," "]
        
    if len(a) >= 20:
        s4 = a[16:20]
    else:
        s4 = [" "," "," "," "]
    
    col = 7 + ((message - 1) * 16)
    
    for i in range(0,4):
        t2 = " %3s %3s %3s %3s" % (s1[i], s2[i], s3[i], s4[i])
        refresh |= draw_string(w, i, col, t2, 16) 
    
f['GPGSV'] = GPGSV

def GPVTG(a):
    if len(a) < 9:
        return
    w = s['NAV']
    refresh = False
    t2 = format_heading(a[1], a[2])
    refresh |= draw_string(w, 0, 60, "%6.6s" % t2)
    try:
        s1 = float(a[5]) * 1.15078
        s2 = float(a[7])
    except:
        s1 = 0.0
        s2 = 0.0

    t2 = "%5.1fMPH %5.1fKPH" % (s1, s2)
    refresh |= draw_string(w, 1, 60, t2)
f['GPVTG'] = GPVTG

def GPZDA(a):
    w = s['TIME']
    if len(a) < 4:
        return
    update_time("%4s-%2s-%2s" % (a[4], a[3], a[2]), 
        "%2s:%2s:%2s" % (a[1][0:2], a[1][2:4],a[1][4:6]))
f['GPZDA'] = GPZDA

def PMTK707(a):
    if len(a) < 6:
        return
    
    w = s['SAT']
    sets = a[1].isdigit() and int(a[1]) or 0
    
    ct = math.floor((time.time() - GPS_OFFSET_SECONDS) / SECONDS_PER_HOUR)
    
    if sets > 0:
        startw = (int(a[2]) * 168 + int(a[3]) / 3600)
        endw = (int(a[4]) * 168 + int(a[5]) / 3600)
        st = " %s   to   %s   Status: %s" % (Convert2UTC(startw), Convert2UTC(endw),
            ((ct >= startw and ct <= endw) and "Usable" or "Unusable"))
    else:
        st = "Not valid"
        
    draw_string(w, 5, 7, st)
f['PMTK707'] = PMTK707
    
def PMTK010(a):
    global lostfix
    if a[1] == "002":
        init_windows()
        lostfix = time.time()            
    draw_string(s['STATUS'], 0, 0, "Running", 14)
f['PMTK010'] = PMTK010
    
def getheightwidth():
    try:
        return int(os.environ["LINES"]), int(os.environ["COLUMNS"])
    except KeyError:
        height, width = struct.unpack(
            "hhhh", fcntl.ioctl(0, termios.TIOCGWINSZ ,"\000"*8))[0:2]
        if not height: return 25, 80
        return height, width

def comm_loop(fg):
    global ex_string
    last_sent = int(time.time())
    while True:
        if not fg.isOpen:
            break
        
        try:
            line = fg.readline()
        except select.error:
            pass
        
        if paused: continue;
        
        line = line.strip()
        if len(line) == 0 or line[0] != "$":
            continue;
        line = line[1:-3]

        if not nmea_paused:
            y, x = s['NMEA'].getmaxyx()
            s['NMEA'].addnstr(y-1, 0, line, x)
            s['NMEA'].refresh()
            if len(line) < x:
                s['NMEA'].scroll(1)

        a = line.split(',')
        stype = a[0]
        if stype in f:
            try:
                f[stype](a)
            except:
                ex_string = traceback.format_exc()
                curses.flushinp()
                curses.ungetch('q')
                break

        tm = int(time.time())
        if tm % 10 == 0 and last_sent != tm:
            send_string(fg, "PMTK607")
            last_sent = tm
      
class comm_loop_thread(Thread):
    def __init__(self, fg):
        Thread.__init__(self)
        self.fg = fg
            
    def run(self):
        comm_loop(self.fg)

def input_loop(fg, thread):
    global paused, nmea_paused, stdscr
    stdscr.nodelay(1)
    while True:
        qq = stdscr.getch()
        if qq <= 0:
            time.sleep(0.250)
            continue
        
        if qq == ord('q'):
            draw_string(s['STATUS'], 0, 0, "Terminating", 15)
            break
        elif qq == ord('p'):
            paused = not paused
            if paused: 
                draw_string(s['STATUS'], 0, 0, "Paused", 15)
            else:
                draw_string(s['STATUS'], 0, 0, "Running", 15) 
        elif qq == ord('n'):
            nmea_paused = not nmea_paused
            if nmea_paused: 
                draw_string(w['NMEA'], 0, 7, "Paused")
            else:
                w['NMEA'].hline(0, 7, curses.ACS_HLINE, 6)
                w['NMEA'].refresh()
            
        elif qq == ord('h'):
            draw_string(s['STATUS'], 0, 0, "Hot Started") 
            send_string(fg, "PMTK101") 
        elif qq == ord('w'):
            draw_string(s['STATUS'], 0, 0, "Warm Started") 
            send_string(fg, "PMTK102") 
        elif qq == ord('c'):
            draw_string(s['STATUS'], 0, 0, "Cold Started") 
            send_string(fg, "PMTK103") 
        elif qq == ord('r'):
            paused = True
            init_windows()
            paused = False 

class input_loop_thread(Thread):
    def __init__(self, fg):
        Thread.__init__(self)
        self.fg = fg
            
    def run(self):
        input_loop(self.fg)
 
def init_windows():
    global width, gps_device
    draw_win('TIME', "Date/Time", 3, width / 2, 0, 0)
    draw_win('STATUS', "Status", 3, width / 2, 0, width / 2)
    draw_string(s['STATUS'], 0, 0, "Running")
    draw_string(s['STATUS'], 0, 15, "Device: %s" % gps_device)
    draw_win('NAV', "Navigation", 4, width, 3, 0)
    draw_win('SAT', "Satellites", 8, width, 7, 0)    
    draw_win('NMEA', "NMEA", 10, width, 15, 0)
    s['NMEA'].scrollok(True)
    s['HELP'] = curses.newwin(1, width, 25, 0)
#                                 123456789012345678901234567890123456789012345678901234567890
    draw_string(s['HELP'], 0, 1, "quit, pause, hot start, warm start, cold start, pause nmea, refresh")
    a = curses.A_BOLD | curses.A_UNDERLINE
    s['HELP'].chgat(0, 1, 1, a)
    s['HELP'].chgat(0, 7, 1, a)
    s['HELP'].chgat(0, 14, 1, a)
    s['HELP'].chgat(0, 25, 1, a)
    s['HELP'].chgat(0, 37, 1, a)
    s['HELP'].chgat(0, 55, 1, a)
    s['HELP'].chgat(0, 61, 1, a)
    s['HELP'].refresh()

def sigwinch_handler(n, frame):
    global width, paused
    paused = True
#    curses.endwin()
#    curses.initscr()
    y, x = getheightwidth()
    curses.resizeterm(y, x)
    init_windows()
    paused = False
 
def main(stds):
    global paused, nmea_paused, stdscr, width, gps_device
    global lostfix, hasfix, gotfix
    
    parser = argparse.ArgumentParser(fromfile_prefix_chars='@',
    description="Displays NMEA Data",
    epilog="You can use '@filename' to read arguments from a file.")
    parser.convert_arg_line_to_args = convert_arg_line_to_args
    parser.add_argument("gps_device", metavar="<GPS_Device>", help="GPS Device")
    args = parser.parse_args()
    
    signal.signal(signal.SIGWINCH, sigwinch_handler)

    gps_device = args.gps_device
    lostfix = time.time()
    hasfix = False
    gotfix = time.time()
    
    stdscr = stds
    stdscr.refresh()
    curses.curs_set(0)
    
    init_windows()
    
    tfg = os.open(args.gps_device, os.O_RDWR)
    params = termios.tcgetattr(tfg);
    previous_baudrate = baudrate[params[5]];
    tty.setraw(tfg, tty.TCSANOW)
    os.close(tfg)

    fg = serial.Serial(port=args.gps_device, timeout=5, baudrate=previous_baudrate)

    thread = comm_loop_thread(fg)
    thread.setDaemon(True)
    thread.start()
    
    input_loop(fg, thread)
    
    if fg and fg.isOpen:
        fg.close()
    
if __name__ == "__main__":
    rc = curses.wrapper(main)
    if ex_string: print >>sys.stderr, ex_string
    sys.exit(rc)
    
